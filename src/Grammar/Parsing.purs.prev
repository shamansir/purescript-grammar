module Grammar.Parsing where

import Prelude

import Debug as Debug

import Grammar (Grammar, AST(..), ASTNode, Rule(..), CharRule(..), At(..), CharX(..), Error(..), RuleName, RuleSet, Range, Tree(..), Attempt(..))
import Grammar (main, find, findIn, set, toChar, toRepr, found, expected, eoi, At(..)) as G

import Control.Lazy (defer)

import Data.Maybe (Maybe(..), fromMaybe, maybe)
import Data.Either (Either(..))
import Data.Traversable (for)
import Data.TraversableWithIndex (forWithIndex)
import Data.FunctorWithIndex (mapWithIndex)
import Data.Array (singleton, fromFoldable, uncons, head, snoc) as Array
import Data.String (take, length, drop) as String
import Data.String.CodeUnits (singleton, charAt) as String
-- import Data.String.CodePoints (eof) as String
import Data.List (List(..)) as List
import Data.Foldable (foldl, class Foldable)

-- import Parsing (Parser, ParseError, Position(..), runParser)
-- import Parsing (position, fail) as P
-- import Parsing.Combinators ((<?>))
-- import Parsing.Combinators as P
import StringParser (Parser(..), ParseError, PosString, runParser)
import StringParser (fail) as P
import StringParser.Combinators as P -- TODO!
import StringParser.CodePoints as P -- TODO!
import Parsing.String
-- import Parsing.Combinators.Array as PA
-- import Parsing.String as P
-- import Parsing.String.Basic as P


type P a = Parser a


parse :: forall a. Grammar -> (Rule -> a) -> String -> Either ParseError (AST a)
parse grammar f str =
    AST $ flip runParser str $ parseRule (G.set grammar) f Main $ G.main grammar


parseRule :: forall a. RuleSet -> (Rule -> a) -> At -> Rule -> P (ASTNode a)
parseRule set f at rule =
    -- TODO: most of the parsers here use `P.fail` from the inside but the error result is then skipped and treated as failure on a higher level (e.g. leaf in the node)
    case rule of
        Text text -> qleaf rule $ P.string text
        CharRule (Single chx) -> qleaf rule $ P.char $ G.toChar chx
        CharRule (Not chx) -> qleaf rule $ do
            mbExclude <- P.optionMaybe $ P.try $ P.char $ G.toChar chx
            case mbExclude of
                Just x -> P.fail $ "found " <> show x
                Nothing -> P.anyChar *> pure unit
        CharRule (Range from to) ->
            qleaf rule
                $ do
                    ch <- P.lookAhead $ P.anyChar
                    if (ch >= from) && (ch <= to) then
                        P.anyChar
                        -- P.advance $ pure ch -- FIXME
                    else P.fail $ show ch <> " is not from range " <> String.singleton from <> "-" <> String.singleton to
                --  $  isFromRange from to
                -- =<< P.anyChar
        CharRule Any -> qleaf rule P.anyChar
        Sequence rules ->
            -- TODO: custom implementation with failure tracking
            qnode rule $ forWithIndex rules $ \idx -> parseRule set f $ InSequence idx
        Choice rules ->
            qnode rule $ Array.singleton <$>
                (_choice failureFromState
                    $ map P.try
                    $ mapWithIndex
                        (\idx -> parseRule set f $ ChoiceOf idx) rules)
        Ref mbCapture ruleName ->
            case G.findIn set ruleName of
                Just foundRule -> parseRule set f (At $ mbCapture # fromMaybe ruleName) foundRule
                Nothing -> P.fail $ "Rule " <> ruleName <> " was not found in grammar"
        RepSep rep sep ->
            let
                prep = parseRule set f RepOf rep
                psep = parseRule set f SepOf sep
            in
                -- qnode $ Array.fromFoldable <$> P.sepEndBy prep psep
                qnode rule $ _repSep rep sep prep psep
        Placeholder ->
            qleaf rule $ P.string "???"
    where
        qleaf :: forall с. Rule -> P с -> P (ASTNode a)
        qleaf = withRange leaf <<< flip mkLeafFailure
        qnode :: Rule -> P (Array (ASTNode a)) -> P (ASTNode a)
        qnode = withRange node <<< flip mkNodeFailure
        leaf :: forall x. x -> Range -> ASTNode a
        leaf _ range = Leaf { at, rule, range } $ f rule
        node :: Array (ASTNode a) -> Range -> ASTNode a
        node rules range = Node { at, rule, range } (f rule) rules
        withRange :: forall c z. (c -> Range -> z) -> (PosString -> z) -> P c -> P z
        withRange mksucc mkfail p = do
            stateBefore <- _state
            mbResult <- P.optionMaybe $ P.try p
            stateAfter <- _state
            case mbResult of
                Just result ->
                    pure $ mksucc result { start : stateBefore.position, end : stateAfter.position }
                Nothing -> do
                    _advance $ advanceFor rule
                    pure $ mkfail stateBefore
        advanceFor :: Rule -> Int
        advanceFor = case _ of
            Text expected -> String.length expected
            CharRule _ -> 1
            Placeholder -> 3
            _ -> 0
        failureFromState :: PosString -> Attempt a
        failureFromState = _failureFromState at rule
        mkLeafFailure :: PosString -> Rule -> Attempt a
        mkLeafFailure state = const $ Leaf $ failureFromState state
        mkNodeFailure :: PosString -> Rule -> Attempt a -- This should never occur when error-saving technique is used, since all parsers in the nodes formally succeed (just signalizing the fail with `Fail` constructor of `AST` datatype)
        mkNodeFailure state = const $ Node (failureFromState state) []


_failureFromState :: forall a. At -> Rule -> PosString -> Attempt a -- Could be `P Failure``
_failureFromState at rule state = Fail state.position $ _makeError state.substring rule


_makeError :: String -> Rule -> Error
_makeError substr =
    case _ of
        Text expected -> TextError { expected : G.expected expected, found : qfoundstr expected }
        CharRule (Single chx) -> CharacterError { expected : G.expected chx, found : qfoundchar substr }
        CharRule (Not chx) -> NegCharacterError { notExpected : G.expected chx, found : qfoundchar substr }
        CharRule (Range from to) -> CharacterRangeError { from : G.expected from, to : G.expected to, found : qfoundchar substr }
        CharRule Any -> AnyCharacterError { found : qfoundchar substr }
        Choice _ -> ChoiceError { }
        Sequence _ -> SequenceError { }
        Ref _ name -> RuleNotFoundError { name }
        RepSep _ _ -> RepSepError { occurence : 0 } -- FIXME
        Placeholder -> PlaceholderError
    where
        qfoundstr expected =
            if String.length substr > 0 then G.found $ String.take (String.length expected) substr else G.eoi
        qfoundchar =
            String.take 1 >>> String.charAt 0 >>> maybe G.eoi G.found -- FIXME: EOL/EOF


type Handlers_ a b = { onEOI :: PosString -> ASTNode a, onFail :: ASTNode a -> P b, onSuccess :: ASTNode a -> P b, onEmpty :: P b }


-- _tryAhead :: forall a b. Handlers_ a b -> P (AST a) -> P b
-- _tryAhead spec p = (P.tryAhead p # P.optionMaybe) >>= _mbHelper spec


-- _try :: forall a b. Handlers_ a b -> P (AST a) -> P b
-- _try spec p = (P.try p # P.optionMaybe) >>= _mbHelper spec


_tryAhead :: forall a b. Handlers_ a b -> P (ASTNode a) -> P b
_tryAhead = _safeTry


_try :: forall a b. Handlers_ a b -> P (ASTNode a) -> P b
_try = _safeTry


_resultOf :: forall a. ASTNode a -> Attempt a
_resultOf = case _ of
    Leaf { result } -> result
    Node { result } _ -> result


_mbHelper :: forall a b. Handlers_ a b -> Maybe (ASTNode a) -> P b
_mbHelper spec =
    case _ of
        Just node -> do
            case _resultOf node of
                -- Fail _ EndOfInput -> pure node -- TODO
                Fail _ _ -> spec.onFail node
                Match _ _ -> spec.onSuccess node
        Nothing -> do
            spec.onEmpty


_choice :: forall a. (PosString -> Error) -> Array (P (ASTNode a)) -> P (ASTNode a)
_choice toFailure = choiceIter [] 0 -- Array.scanl ??? FIXME
    where
        choiceIter :: Array (AST a) -> Int -> Array (P (AST a)) -> P (ASTNode a) -- FIXME: return children array instead and wrap it in the AST node above
        choiceIter results idx items =
            case Array.uncons items of
                Just { head, tail } -> do
                    head # _tryAhead
                        { onEmpty : ?wh
                        , onEOI : ?wh -- FIXME: TODO
                        , onFail :
                            \failure -> do
                                let _ = Debug.spy "next in choice" $ idx + 1
                                choiceIter (failure # Array.snoc results) (idx + 1) tail
                        , onSuccess : \succ -> do
                            let _ = Debug.spy "success" succ
                            pure succ
                        }
                Nothing -> do
                    curState <- _state
                    pure $ Node (toFailure curState) results


 -- duplicate of `choice`` which works the same way but with slightly different algorithm (`try` instead of `tryAhead` + `assertConsume`, but then rollbacks on failure), test speed
_choice' :: forall a. (PosString -> Error) -> Array (P (ASTNode a)) -> P (ASTNode a)
_choice' toFailure = choiceIter [] 0 -- Array.scanl ??? FIXME
    where
        choiceIter :: Array (ASTNode a) -> Int -> Array (P (ASTNode a)) -> P (ASTNode a) -- FIXME: return children array instead and wrap it in the AST node above
        choiceIter results idx items =
            case Array.uncons items of
                Just { head, tail } -> do
                    head # _try
                        { onEmpty : ?wh
                        , onEOI : ?wh -- FIXME: TODO
                        , onFail :
                            \failure -> do
                                choiceIter (failure # Array.snoc results) (idx + 1) tail
                        , onSuccess : pure
                        }
                Nothing -> do
                    curState <- _state
                    pure $ Node (toFailure curState) results


_repSep :: forall a. Rule -> Rule -> P (ASTNode a) -> P (ASTNode a) -> P (Array (ASTNode a))
_repSep reprule seprule rep sep = do
    rep # _tryAhead
        { onEmpty : pure [] -- FIXME
        , onEOI : qRepFailure
        , onFail : pure <<< Array.singleton
        , onSuccess :
            \repSuccess ->
                repSepIter (Array.singleton repSuccess) 1
        }
    where
        qRepFailure :: PosString -> ASTNode a
        qRepFailure state = Leaf { rule : reprule, result : _failureFromState G.RepOf reprule state }
        qSepFailure :: PosString -> ASTNode a
        qSepFailure state = Leaf { rule : seprule, result : _failureFromState G.SepOf seprule state }
        repSepIter :: Array (ASTNode a) -> Int -> P (Array (ASTNode a))
        repSepIter results index = do
            sep # _tryAhead
                { onEmpty : pure [] -- FIXME
                , onEOI : qSepFailure -- FIXME: doesn't pass EOI inside
                , onFail : \sepFailure -> pure (sepFailure # Array.snoc results)
                , onSuccess :
                    \sepSuccess -> do
                        rep # _tryAhead
                            { onEmpty : pure []-- FIXME
                            , onEOI : qRepFailure
                            , onFail :
                                \repFailure ->
                                    pure (sepSuccess # Array.snoc (repFailure # Array.snoc results))
                            , onSuccess :
                                \repSuccess -> do
                                    repSepIter (repSuccess # Array.snoc (sepSuccess # Array.snoc results)) $ index + 1
                            }
                }


_safeTry :: forall a b. Handlers_ a b -> P (ASTNode a) -> P b
_safeTry spec what = do
    stateBefore <- _state
    result <- _ensureNotEOIWith spec.onEOI $ P.optionMaybe $ what
    result # _mbHelper
        { onEmpty : spec.onEmpty
        , onEOI : spec.onEOI
        , onSuccess : spec.onSuccess
        , onFail : \res -> do
            _ <- _rollback stateBefore
            spec.onFail res
        }


_ensureNotEOIWith :: forall a. (PosString -> a)-> P (Maybe a) -> P (Maybe a)
_ensureNotEOIWith fallback p = do
    state <- _state
    if (String.length state.substring == 0) then do
        pure $ Just $ fallback state
    else p >>= pure


_isEOI :: P Boolean
_isEOI = Parser $
    \state ->
        Right { result : String.length state.substring == 0, suffix : state }


_rollback :: PosString -> P Unit
_rollback state = Parser $ const $ pure { result : unit, suffix : state }


_advance :: Int -> P Unit
_advance howMuch =
    Parser $ \state ->
        let
            substrLen = String.length state.substring
            safeHowMuch = if substrLen < howMuch then substrLen else howMuch
        in
            pure
                { result : unit
                , suffix :
                    { position : state.position + safeHowMuch
                    , substring : String.drop safeHowMuch state.substring
                    }
                }


_state :: P PosString
_state = Parser \state -> pure { result : state, suffix : state }


_position :: P Int
_position = Parser \state -> pure { result : state.position, suffix : state }